// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc348.RecycleRushForklift.subsystems;

import org.usfirst.frc348.RecycleRushForklift.RobotMap;
import org.usfirst.frc348.RecycleRushForklift.commands.*;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.I2C;
import org.apache.commons.math3.geometry.euclidean.threed.*;

/**
 *
 */
public class AttitudeandHeadingReferenceSystem extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	private I2C accelerometerAndMagnetometer = new I2C(I2C.Port.kOnboard, 0x1d);
	private I2C gyro = new I2C(I2C.Port.kOnboard, 0x6b);

    private double accelerometerScale; // m/s^2 per lsb
    private double gyroScale; // rad/s per lsb
    private double magnetometerScale; // T per lsb
    private Rotation sensorFrameToVehicleFrame = Rotation.IDENTITY;
    
    enum GyroRegister
    {
    	WHO_AM_I_G(0x0F),
    	CTRL_REG1_G(0x20),
    	CTRL_REG2_G(0x21),
    	CTRL_REG3_G(0x22),
    	CTRL_REG4_G(0x23),
    	CTRL_REG5_G(0x24),
    	REFERENCE_G(0x25),
    	STATUS_REG_G(0x27),
    	OUT_X_L_G(0x28),
    	OUT_X_H_G(0x29),
    	OUT_Y_L_G(0x2A),
    	OUT_Y_H_G(0x2B),
    	OUT_Z_L_G(0x2C),
    	OUT_Z_H_G(0x2D),
    	FIFO_CTRL_REG_G(0x2E),
    	FIFO_SRC_REG_G(0x2F),
    	INT1_CFG_G(0x30),
    	INT1_SRC_G(0x31),
    	INT1_THS_XH_G(0x32),
    	INT1_THS_XL_G(0x33),
    	INT1_THS_YH_G(0x34),
    	INT1_THS_YL_G(0x35),
    	INT1_THS_ZH_G(0x36),
    	INT1_THS_ZL_G(0x37),
    	INT1_DURATION_G(0x38);
    	
        private int value;

        public byte value() { return (byte)this.value; }
        
    	private GyroRegister(int value) {
               this.value = value;
    	}
    }
    
    enum AccelerometerAndMagnetometerRegister
    {
    	 OUT_TEMP_L_XM(0x05),
    	 OUT_TEMP_H_XM(0x06),
    	 STATUS_REG_M(0x07),
    	 OUT_X_L_M(0x08),
    	 OUT_X_H_M(0x09),
    	 OUT_Y_L_M(0x0A),
    	 OUT_Y_H_M(0x0B),
    	 OUT_Z_L_M(0x0C),
    	 OUT_Z_H_M(0x0D),
    	 WHO_AM_I_XM(0x0F),
    	 INT_CTRL_REG_M(0x12),
    	 INT_SRC_REG_M(0x13),
    	 INT_THS_L_M(0x14),
    	 INT_THS_H_M(0x15),
    	 OFFSET_X_L_M(0x16),
    	 OFFSET_X_H_M(0x17),
    	 OFFSET_Y_L_M(0x18),
    	 OFFSET_Y_H_M(0x19),
    	 OFFSET_Z_L_M(0x1A),
    	 OFFSET_Z_H_M(0x1B),
    	 REFERENCE_X(0x1C),
    	 REFERENCE_Y(0x1D),
    	 REFERENCE_Z(0x1E),
    	 CTRL_REG0_XM(0x1F),
    	 CTRL_REG1_XM(0x20),
    	 CTRL_REG2_XM(0x21),
    	 CTRL_REG3_XM(0x22),
    	 CTRL_REG4_XM(0x23),
    	 CTRL_REG5_XM(0x24),
    	 CTRL_REG6_XM(0x25),
    	 CTRL_REG7_XM(0x26),
    	 STATUS_REG_A(0x27),
    	 OUT_X_L_A(0x28),
    	 OUT_X_H_A(0x29),
    	 OUT_Y_L_A(0x2A),
    	 OUT_Y_H_A(0x2B),
    	 OUT_Z_L_A(0x2C),
    	 OUT_Z_H_A(0x2D),
    	 FIFO_CTRL_REG(0x2E),
    	 FIFO_SRC_REG(0x2F),
    	 INT_GEN_1_REG(0x30),
    	 INT_GEN_1_SRC(0x31),
    	 INT_GEN_1_THS(0x32),
    	 INT_GEN_1_DURATION(0x33),
    	 INT_GEN_2_REG(0x34),
    	 INT_GEN_2_SRC(0x35),
    	 INT_GEN_2_THS(0x36),
    	 INT_GEN_2_DURATION(0x37),
    	 CLICK_CFG(0x38),
    	 CLICK_SRC(0x39),
    	 CLICK_THS(0x3A),
    	 TIME_LIMIT(0x3B),
    	 TIME_LATENCY(0x3C),
    	 TIME_WINDOW(0x3D),
    	 ACT_THS(0x3E),
    	 ACT_DUR(0x3F);
    	
        private int value;
        
        public byte value() { return (byte)this.value; }

    	private AccelerometerAndMagnetometerRegister(int value) {
               this.value = value;
    	}
    }

    // Adapted from work by Jim Lindblom @ SparkFun Electronics
	// defines the possible full-scale ranges of the gyroscope:
    public enum GyroScale
    {
    	G_SCALE_245DPS(0b00), // 00: 245 degrees per second
    	G_SCALE_500DPS(0b01), // 01: 500 dps
    	G_SCALE_2000DPS(0b10); // 10: 2000 dps
    	
        private int value;
        
        public byte value() { return (byte)this.value; }

    	private GyroScale(int value) {
               this.value = value;
    	}
    }
    
    // defines all possible FSR's of the accelerometer:
    public enum AccelerometerScale
	{
		A_SCALE_2G(0b000), // 000: 2g
		A_SCALE_4G(0b001), // 001: 4g
		A_SCALE_6G(0b010), // 010: 6g
		A_SCALE_8G(0b011), // 011: 8g
		A_SCALE_16G(0b100); // 100: 16g
		
		private int value;
        
        public byte value() { return (byte)this.value; }

    	private AccelerometerScale(int value) {
               this.value = value;
    	}
	}

    // defines all possible FSR's of the magnetometer:
	public enum MagnetometerScale
	{
		M_SCALE_2GS(0b00), // 00: 2Gs
		M_SCALE_4GS(0b01), // 01: 4Gs
		M_SCALE_8GS(0b10), // 10: 8Gs
		M_SCALE_12GS(0b11); // 11: 12Gs
		
		private int value;
		
		public byte value() { return (byte)this.value; }
		
		private MagnetometerScale(int value) {
		       this.value = value;
		}
	}
	
	// defines all possible data rate/bandwidth combos of the gyro:
	public enum GyroOutputDataRate
	{ 	
		// ODR (Hz) --- Cutoff
		G_ODR_95_BW_125(0x0), // 95 12.5
		G_ODR_95_BW_25(0x1), // 95 25
		// 0x2 and 0x3 define the same data rate and bandwidth
		G_ODR_190_BW_125(0x4), // 190 12.5
		G_ODR_190_BW_25(0x5), // 190 25
		G_ODR_190_BW_50(0x6), // 190 50
		G_ODR_190_BW_70(0x7), // 190 70
		G_ODR_380_BW_20(0x8), // 380 20
		G_ODR_380_BW_25(0x9), // 380 25
		G_ODR_380_BW_50(0xA), // 380 50
		G_ODR_380_BW_100(0xB), // 380 100
		G_ODR_760_BW_30(0xC), // 760 30
		G_ODR_760_BW_35(0xD), // 760 35
		G_ODR_760_BW_50(0xE), // 760 50
		G_ODR_760_BW_100(0xF); // 760 100
		
		private int value;
		
		public byte value() { return (byte)this.value; }
		
		private GyroOutputDataRate(int value) {
		       this.value = value;
		}
	}
	
	// defines all possible output data rates of the accelerometer:
	public enum AccelerometerOutputDataRate
	{
		A_POWER_DOWN(0x0), // Power-down mode (0x0)
		A_ODR_3125(0x01), // 3.125 Hz (0x1)
		A_ODR_625(0x02), // 6.25 Hz (0x2)
		A_ODR_125(0x03), // 12.5 Hz (0x3)
		A_ODR_25(0x04), // 25 Hz (0x4)
		A_ODR_50(0x05), // 50 Hz (0x5)
		A_ODR_100(0x06), // 100 Hz (0x6)
		A_ODR_200(0x07), // 200 Hz (0x7)
		A_ODR_400(0x08), // 400 Hz (0x8)
		A_ODR_800(0x09), // 800 Hz (9)
		A_ODR_1600(0x0a); // 1600 Hz (0xA)
		
		private int value;
		
		public byte value() { return (byte)this.value; }
		
		private AccelerometerOutputDataRate(int value) {
		       this.value = value;
		}
	}
	
	// defines all possible anti-aliasing filter rates of the accelerometer:
	public enum AccelerometerBandwidth
	{
		A_ABW_773(0x0), // 773 Hz (0x0)
		A_ABW_194(0x1), // 194 Hz (0x1)
		A_ABW_362(0x2), // 362 Hz (0x2)
		A_ABW_50(0x3); // 50 Hz (0x3)
		
		private int value;
		
		public byte value() { return (byte)this.value; }
		
		private AccelerometerBandwidth(int value) {
		       this.value = value;
		}
	}
	
	// mag_oder defines all possible output data rates of the magnetometer:
	public enum MagnetometerOutputDataRate
	{
		M_ODR_3125(0x0), // 3.125 Hz (0x00)
		M_ODR_625(0x1), // 6.25 Hz (0x01)
		M_ODR_125(0x2), // 12.5 Hz (0x02)
		M_ODR_25(0x3), // 25 Hz (0x03)
		M_ODR_50(0x4), // 50 (0x04)
		M_ODR_100(0x5); // 100 Hz (0x05)
		
		private int value;
		
		public byte value() { return (byte)this.value; }
		
		private MagnetometerOutputDataRate(int value) {
		       this.value = value;
		}
	};
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new UpdateAHRSEstimate());
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public void SetRotationFromSensorFrameToVehicleFrame(Rotation sensorFrameToVehicleFrame)
    {
    	this.sensorFrameToVehicleFrame = sensorFrameToVehicleFrame;
    }
    
    private void WriteRegister(GyroRegister register, byte value)
    {
    	gyro.write(register.value(), value);
    }
    
    private void WriteRegister(AccelerometerAndMagnetometerRegister register, byte value)
    {
    	accelerometerAndMagnetometer.write(register.value(), value);
    }
    
    private boolean VerifyRegister(GyroRegister register, byte expected)
    {
    	byte[] result = new byte[1];
    	boolean aborted = gyro.read(register.value(), 1, result);
    	
    	if(aborted) return false;
    	else return result[0] == expected;
    }
    
    private boolean VerifyRegister(AccelerometerAndMagnetometerRegister register, byte expected)
    {
    	byte[] result = new byte[1];
    	boolean aborted = accelerometerAndMagnetometer.read(register.value(), 1, result);
    	
    	if(aborted) return false;
    	else return result[0] == expected;
    }
    
    public Vector3D ReadAcceleration() 
    {
    	byte[] data = ReadMultipleRegisters(AccelerometerAndMagnetometerRegister.OUT_X_L_A, 6);
    	
    	if(data == null) return null;
    	
    	return ReadScaleTransform(accelerometerScale, data);
    }
    
    public Vector3D ReadMagneticField()
    {
    	byte[] data = ReadMultipleRegisters(AccelerometerAndMagnetometerRegister.OUT_X_L_M, 6);
    	
    	if(data == null) return null;
    	
    	return ReadScaleTransform(magnetometerScale, data);
    }
    
    public Vector3D ReadAngularVelocity()
    {
    	byte[] data = ReadMultipleRegisters(GyroRegister.OUT_X_L_G, 6);
    	
    	if(data == null) return null;
    	
    	return ReadScaleTransform(gyroScale, data);
    }
    
    private byte[] ReadMultipleRegisters(GyroRegister register, int n)
    {
    	return ReadMultipleRegisters(gyro, register.value(), n);
    }
    
    private byte[] ReadMultipleRegisters(AccelerometerAndMagnetometerRegister register, int n)
    {
    	return ReadMultipleRegisters(accelerometerAndMagnetometer, register.value(), n);
    }
    
    private byte[] ReadMultipleRegisters(I2C sensor, byte register, int n)
    {
    	byte[] toSend = new byte[1];
    	toSend[0] = (byte)(register | 0x80); // high MSB indicates auto-increment of register address
    	
    	byte[] received = new byte[n];
    	
    	if(sensor.transaction(toSend, 1, received, n)) {
    		// transaction aborted
    		return null;
    	}
    	else {
    		// success
    		return received;
    	}
    }
    
    private Vector3D ReadScaleTransform(double scale, byte[] littleEndianBytes)
    {
    	double[] result = new double[3];
    	for(int i = 0; i < 3; i++)
    	{
    		short value = (short)(littleEndianBytes[2*i] | (littleEndianBytes[2*i + 1] << 8));
    		result[i] = scale * value;
    	}
    	
    	Vector3D sensorFrame = new Vector3D(result);
    	return sensorFrameToVehicleFrame.applyTo(sensorFrame);
    }
    
    public void InitializeSensors()
    {
    	// sensible defaults for FRC
    	
    	InitializeGyro(GyroScale.G_SCALE_500DPS, GyroOutputDataRate.G_ODR_95_BW_25);
    	InitializeAccelerometer(AccelerometerScale.A_SCALE_4G, AccelerometerOutputDataRate.A_ODR_50, AccelerometerBandwidth.A_ABW_50);
    	InitializeMagnetometer(MagnetometerScale.M_SCALE_2GS, MagnetometerOutputDataRate.M_ODR_50);
    }
    
    public void InitializeGyro(GyroScale scale, GyroOutputDataRate odr)
    {
    	if(!VerifyRegister(GyroRegister.WHO_AM_I_G, (byte)0b11010100))
    	{
    		// trace a message saying we had problems
    	}
    	
    	/* CTRL_REG1_G sets output data rate, bandwidth, power-down and enables
    	Bits[7:0]: DR1 DR0 BW1 BW0 PD Zen Xen Yen
    	DR[1:0] - Output data rate selection
    	00=95Hz, 01=190Hz, 10=380Hz, 11=760Hz
    	BW[1:0] - Bandwidth selection (sets cutoff frequency)
    	Value depends on ODR. See datasheet table 21.
    	PD - Power down enable (0=power down mode, 1=normal or sleep mode)
    	Zen, Xen, Yen - Axis enable (o=disabled, 1=enabled) */
    	byte ctrl_reg1_g = (byte)((odr.value() << 4) | 0b1111); // non-sleep mode, enable all axes
    	WriteRegister(GyroRegister.CTRL_REG1_G, ctrl_reg1_g);
    	
    	/* CTRL_REG2_G sets up the HPF
    	Bits[7:0]: 0 0 HPM1 HPM0 HPCF3 HPCF2 HPCF1 HPCF0
    	HPM[1:0] - High pass filter mode selection
    	00=normal (reset reading HP_RESET_FILTER, 01=ref signal for filtering,
    	10=normal, 11=autoreset on interrupt
    	HPCF[3:0] - High pass filter cutoff frequency
    	Value depends on data rate. See datasheet table 26.
    	*/
    	WriteRegister(GyroRegister.CTRL_REG2_G, (byte)0);
    	
    	/* CTRL_REG3_G sets up interrupt and DRDY_G pins
    	Bits[7:0]: I1_IINT1 I1_BOOT H_LACTIVE PP_OD I2_DRDY I2_WTM I2_ORUN I2_EMPTY
    	I1_INT1 - Interrupt enable on INT_G pin (0=disable, 1=enable)
    	I1_BOOT - Boot status available on INT_G (0=disable, 1=enable)
    	H_LACTIVE - Interrupt active configuration on INT_G (0:high, 1:low)
    	PP_OD - Push-pull/open-drain (0=push-pull, 1=open-drain)
    	I2_DRDY - Data ready on DRDY_G (0=disable, 1=enable)
    	I2_WTM - FIFO watermark interrupt on DRDY_G (0=disable 1=enable)
    	I2_ORUN - FIFO overrun interrupt on DRDY_G (0=disable 1=enable)
    	I2_EMPTY - FIFO empty interrupt on DRDY_G (0=disable 1=enable) */
    	byte ctrl_reg3_g = 0b00010000; // disable interrupts
    	WriteRegister(GyroRegister.CTRL_REG3_G, ctrl_reg3_g);
    	
    	/* CTRL_REG4_G sets the scale, update mode
    	Bits[7:0] - BDU BLE FS1 FS0 - ST1 ST0 SIM
    	BDU - Block data update (0=continuous, 1=output not updated until read
    	BLE - Big/little endian (0=data LSB @ lower address, 1=LSB @ higher add)
    	FS[1:0] - Full-scale selection
    	00=245dps, 01=500dps, 10=2000dps, 11=2000dps
    	ST[1:0] - Self-test enable
    	00=disabled, 01=st 0 (x+, y-, z-), 10=undefined, 11=st 1 (x-, y+, z+)
    	SIM - SPI serial interface mode select
    	0=4 wire, 1=3 wire */
    	byte ctrl_reg4_g = (byte)((scale.value() << 4) | 0b00000000); // not in self-test mode
    	WriteRegister(GyroRegister.CTRL_REG4_G, ctrl_reg4_g);
    	
    	/* CTRL_REG5_G sets up the FIFO, HPF, and INT1
    	Bits[7:0] - BOOT FIFO_EN - HPen INT1_Sel1 INT1_Sel0 Out_Sel1 Out_Sel0
    	BOOT - Reboot memory content (0=normal, 1=reboot)
    	FIFO_EN - FIFO enable (0=disable, 1=enable)
    	HPen - HPF enable (0=disable, 1=enable)
    	INT1_Sel[1:0] - Int 1 selection configuration
    	Out_Sel[1:0] - Out selection configuration */
    	WriteRegister(GyroRegister.CTRL_REG5_G, (byte)0);
    	
    	// compute scale factor
    	int dps = 0;
    	switch(scale) 
    	{
    	case G_SCALE_245DPS:
    		dps = 245;
    		break;
    	case G_SCALE_500DPS:
    		dps = 500;
    		break;
    	case G_SCALE_2000DPS:
    		dps = 2000;
			break;
    	}
    	
    	gyroScale = (Math.PI * dps / 180.0) / 32768.0; // scale in rad/s per LSB
    }
    
    public void InitializeMagnetometer(MagnetometerScale scale, MagnetometerOutputDataRate odr)
    {
    	if(!VerifyRegister(AccelerometerAndMagnetometerRegister.WHO_AM_I_XM, (byte)0b01001001))
    	{
    		// trace a message saying we had problems
    	}
    	
    	/* CTRL_REG5_XM enables temp sensor, sets mag resolution and data rate
    	Bits (7-0): TEMP_EN M_RES1 M_RES0 M_ODR2 M_ODR1 M_ODR0 LIR2 LIR1
    	TEMP_EN - Enable temperature sensor (0=disabled, 1=enabled)
    	M_RES[1:0] - Magnetometer resolution select (0=low, 3=high)
    	M_ODR[2:0] - Magnetometer data rate select
    	000=3.125Hz, 001=6.25Hz, 010=12.5Hz, 011=25Hz, 100=50Hz, 101=100Hz
    	LIR2 - Latch interrupt request on INT2_SRC (cleared by reading INT2_SRC)
    	0=interrupt request not latched, 1=interrupt request latched
    	LIR1 - Latch interrupt request on INT1_SRC (cleared by readging INT1_SRC)
    	0=irq not latched, 1=irq latched */
    	byte ctrl_reg5_xm = (byte)((odr.value() << 2) | 0b10000000);
    	WriteRegister(AccelerometerAndMagnetometerRegister.CTRL_REG5_XM, ctrl_reg5_xm);
    	
    	/* CTRL_REG6_XM sets the magnetometer full-scale
    	Bits (7-0): 0 MFS1 MFS0 0 0 0 0 0
    	MFS[1:0] - Magnetic full-scale selection
    	00:+/-2Gauss, 01:+/-4Gs, 10:+/-8Gs, 11:+/-12Gs */
    	byte ctrl_reg6_xm = (byte)((scale.value() << 5));
    	WriteRegister(AccelerometerAndMagnetometerRegister.CTRL_REG6_XM, ctrl_reg6_xm);
    	
    	/* CTRL_REG7_XM sets magnetic sensor mode, low power mode, and filters
    	AHPM1 AHPM0 AFDS 0 0 MLP MD1 MD0
    	AHPM[1:0] - HPF mode selection
    	00=normal (resets reference registers), 01=reference signal for filtering,
    	10=normal, 11=autoreset on interrupt event
    	AFDS - Filtered acceleration data selection
    	0=internal filter bypassed, 1=data from internal filter sent to FIFO
    	MLP - Magnetic data low-power mode
    	0=data rate is set by M_ODR bits in CTRL_REG5
    	1=data rate is set to 3.125Hz
    	MD[1:0] - Magnetic sensor mode selection (default 10)
    	00=continuous-conversion, 01=single-conversion, 10 and 11=power-down */
    	byte ctrl_reg7_xm = (byte)0b00000000; // continuous conversion, not low-power mode, filter bypassed
    	WriteRegister(AccelerometerAndMagnetometerRegister.CTRL_REG7_XM, ctrl_reg7_xm);
    	
    	/* CTRL_REG4_XM is used to set interrupt generators on INT2_XM
    	Bits (7-0): P2_TAP P2_INT1 P2_INT2 P2_INTM P2_DRDYA P2_DRDYM P2_Overrun P2_WTM
    	*/
    	WriteRegister(AccelerometerAndMagnetometerRegister.CTRL_REG4_XM, (byte)0x00);
    	
    	/* INT_CTRL_REG_M to set push-pull/open drain, and active-low/high
    	Bits[7:0] - XMIEN YMIEN ZMIEN PP_OD IEA IEL 4D MIEN
    	XMIEN, YMIEN, ZMIEN - Enable interrupt recognition on axis for mag data
    	PP_OD - Push-pull/open-drain interrupt configuration (0=push-pull, 1=od)
    	IEA - Interrupt polarity for accel and magneto
    	0=active-low, 1=active-high
    	IEL - Latch interrupt request for accel and magneto
    	0=irq not latched, 1=irq latched
    	4D - 4D enable. 4D detection is enabled when 6D bit in INT_GEN1_REG is set
    	MIEN - Enable interrupt generation for magnetic data
    	0=disable, 1=enable) */
    	byte int_ctrl_reg_m = (byte)0b00001000; // disable interrupts for magnetometer
    	WriteRegister(AccelerometerAndMagnetometerRegister.INT_CTRL_REG_M, int_ctrl_reg_m);
    	
    	// compute scale factor
    	int gauss = 0;
    	switch(scale)
    	{
    	case M_SCALE_2GS:
    		gauss = 2;
    		break;
    	case M_SCALE_4GS:
    		gauss = 4;
    		break;
    	case M_SCALE_8GS:
    		gauss = 8;
    		break;
    	case M_SCALE_12GS:
    		gauss = 12;
    		break;
    	}
    	
    	magnetometerScale = (0.0001 * gauss) / 32768.0; // scale in Tesla per LSB
    }
    
    public void InitializeAccelerometer(AccelerometerScale scale, AccelerometerOutputDataRate odr, AccelerometerBandwidth bw) 
    {
    	if(!VerifyRegister(AccelerometerAndMagnetometerRegister.WHO_AM_I_XM, (byte)0b01001001))
    	{
    		// trace a message saying we had problems
    	}
    	
    	/* CTRL_REG0_XM (0x1F) (Default value: 0x00)
    	Bits (7-0): BOOT FIFO_EN WTM_EN 0 0 HP_CLICK HPIS1 HPIS2
    	BOOT - Reboot memory content (0: normal, 1: reboot)
    	FIFO_EN - Fifo enable (0: disable, 1: enable)
    	WTM_EN - FIFO watermark enable (0: disable, 1: enable)
    	HP_CLICK - HPF enabled for click (0: filter bypassed, 1: enabled)
    	HPIS1 - HPF enabled for interrupt generator 1 (0: bypassed, 1: enabled)
    	HPIS2 - HPF enabled for interrupt generator 2 (0: bypassed, 1 enabled) */
    	WriteRegister(AccelerometerAndMagnetometerRegister.CTRL_REG0_XM, (byte)0x00);
    	
    	/* CTRL_REG1_XM (0x20) (Default value: 0x07)
    	Bits (7-0): AODR3 AODR2 AODR1 AODR0 BDU AZEN AYEN AXEN
    	AODR[3:0] - select the acceleration data rate:
    	0000=power down, 0001=3.125Hz, 0010=6.25Hz, 0011=12.5Hz,
    	0100=25Hz, 0101=50Hz, 0110=100Hz, 0111=200Hz, 1000=400Hz,
    	1001=800Hz, 1010=1600Hz, (remaining combinations undefined).
    	BDU - block data update for accel AND mag
    	0: Continuous update
    	1: Output registers aren't updated until MSB and LSB have been read.
    	AZEN, AYEN, and AXEN - Acceleration x/y/z-axis enabled.
    	0: Axis disabled, 1: Axis enabled */	
    	byte ctrl_reg1_xm = (byte)((odr.value() << 4) | 0b0111); // enable all axes
    	WriteRegister(AccelerometerAndMagnetometerRegister.CTRL_REG1_XM, ctrl_reg1_xm);
    	
    	/* CTRL_REG2_XM (0x21) (Default value: 0x00)
    	Bits (7-0): ABW1 ABW0 AFS2 AFS1 AFS0 AST1 AST0 SIM
    	ABW[1:0] - Accelerometer anti-alias filter bandwidth
    	00=773Hz, 01=194Hz, 10=362Hz, 11=50Hz
    	AFS[2:0] - Accel full-scale selection
    	000=+/-2g, 001=+/-4g, 010=+/-6g, 011=+/-8g, 100=+/-16g
    	AST[1:0] - Accel self-test enable
    	00=normal (no self-test), 01=positive st, 10=negative st, 11=not allowed
    	SIM - SPI mode selection
    	0=4-wire, 1=3-wire */
    	byte ctrl_reg2_xm = (byte)((bw.value() << 6) | (scale.value() << 3) | 0b000); // self test not in progress
    	WriteRegister(AccelerometerAndMagnetometerRegister.CTRL_REG2_XM, ctrl_reg2_xm);
    	
    	/* CTRL_REG3_XM is used to set interrupt generators on INT1_XM
    	Bits (7-0): P1_BOOT P1_TAP P1_INT1 P1_INT2 P1_INTM P1_DRDYA P1_DRDYM P1_EMPTY
    	*/
    	WriteRegister(AccelerometerAndMagnetometerRegister.CTRL_REG3_XM, (byte)0x00);
    	
    	// compute scale factor
    	int gee = 0;
    	switch(scale) 
    	{
    	case A_SCALE_2G:
    		gee = 2;
    		break;
    	case A_SCALE_4G:
    		gee = 4;
    		break;
    	case A_SCALE_6G:
    		gee = 6;
    		break;    		
    	case A_SCALE_8G:
    		gee = 8;
    		break;
    	case A_SCALE_16G:
    		gee = 16;
    		break;
    	}
    	
    	accelerometerScale = (9.80665 * gee) / 32768.0; // scale in m/s^2 per LSB
    }
}

